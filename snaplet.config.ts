// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path=".snaplet/snaplet.d.ts" />
// This config was generated by Snaplet make sure to check it over before using it.
import { copycat, faker } from "@snaplet/copycat";
import { defineConfig } from "snaplet";
export default defineConfig({
  transform: {
    $mode: "unsafe",
    public: {
      alarm_feeds({ row }) {
        return {
          users: copycat.int(row.users, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
        };
      },
      markers({ row }) {
        return {
          longitude: copycat
            .float(row.longitude, {
              min: -90,
              max: 90,
            })
            .toString(),
          latitude: copycat
            .float(row.latitude, {
              min: -90,
              max: 90,
            })
            .toString(),
        };
      },
      mission_clear_user({ row }) {
        return {
          users: copycat.int(row.users, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
        };
      },
      obtain_histories({ row }) {
        return {
          created_at: copycat.dateString(row.created_at, {
            minYear: 2020,
          }),
          ingredient: copycat.int(row.ingredient, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
          ingredient_name: copycat.sentence(row.ingredient_name),
          nickname: copycat.sentence(row.nickname),
          is_reward: copycat.bool(row.is_reward),
        };
      },
      users({ row }) {
        return {
          phone: copycat.phoneNumber(row.phone),
          nickname: copycat.fullName(row.nickname),
          ticket: copycat.int(row.ticket, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
          marker_obtain_count: copycat.int(row.marker_obtain_count, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
          level: copycat.int(row.level, {
            min: 0,
            max: Math.pow(8, 8) - 1,
          }),
        };
      },
    },
    auth: {
      audit_log_entries({ row }) {
        return {
          ip_address: copycat.scramble(row.ip_address),
        };
      },
      flow_state({ row }) {
        return {
          auth_code: copycat.state(row.auth_code),
          provider_type: copycat.state(row.provider_type),
          provider_access_token: copycat.uuid(row.provider_access_token),
          provider_refresh_token: copycat.uuid(row.provider_refresh_token),
        };
      },
      identities({ row }) {
        return {
          identity_data: {
            [copycat.word(row.identity_data)]: copycat.words(row.identity_data),
          },
        };
      },
      mfa_challenges({ row }) {
        return {
          ip_address: copycat.ipv4(row.ip_address),
        };
      },
      mfa_factors({ row }) {
        return {
          secret: copycat.streetAddress(row.secret),
        };
      },
      refresh_tokens({ row }) {
        return {
          token: copycat.scramble(row.token, {
            preserve: [],
          }),
          parent: copycat.scramble(row.parent, {
            preserve: [],
          }),
        };
      },
      saml_providers({ row }) {
        return {
          metadata_xml: copycat.sentence(row.metadata_xml),
          attribute_mapping: {
            [copycat.word(row.attribute_mapping)]: copycat.words(
              row.attribute_mapping
            ),
          },
        };
      },
      saml_relay_states({ row }) {
        return {
          for_email: copycat.email(row.for_email),
          from_ip_address: copycat.ipv4(row.from_ip_address),
        };
      },
      sso_domains({ row }) {
        return {
          domain: copycat.email(row.domain),
        };
      },
      users({ row }) {
        return {
          role: copycat.fullName(row.role, {
            limit: 255,
          }),
          email: copycat.email(row.email, {
            limit: 255,
          }),
          encrypted_password: copycat.scramble(row.encrypted_password),
          confirmation_token: copycat.scramble(row.confirmation_token, {
            preserve: [],
          }),
          recovery_token: copycat.scramble(row.recovery_token, {
            preserve: [],
          }),
          email_change_token_new: copycat.scramble(row.email_change_token_new, {
            preserve: [],
          }),
          email_change: copycat.email(row.email_change, {
            limit: 255,
          }),
          raw_app_meta_data: {
            [copycat.word(row.raw_app_meta_data)]: copycat.words(
              row.raw_app_meta_data
            ),
          },
          raw_user_meta_data: {
            [copycat.word(row.raw_user_meta_data)]: copycat.words(
              row.raw_user_meta_data
            ),
          },
          phone: copycat.phoneNumber(row.phone),
          phone_change: copycat.phoneNumber(row.phone_change),
          phone_change_token: copycat.scramble(row.phone_change_token, {
            preserve: [],
          }),
          email_change_token_current: copycat.scramble(
            row.email_change_token_current,
            {
              preserve: [],
            }
          ),
          reauthentication_token: copycat.scramble(row.reauthentication_token, {
            preserve: [],
          }),
        };
      },
    },
    storage: {
      migrations({ row }) {
        return {
          hash: copycat.scramble(row.hash),
        };
      },
      objects({ row }) {
        return {
          metadata: {
            [copycat.word(row.metadata)]: copycat.words(row.metadata),
          },
        };
      },
    },
    pgsodium: {
      key({ row }) {
        return {
          name: copycat.fullName(row.name),
          associated_data: copycat.sentence(row.associated_data),
          parent_key: copycat.uuid(row.parent_key),
          comment: copycat.uuid(row.comment),
          user_data: copycat.sentence(row.user_data),
        };
      },
    },
    realtime: {
      subscription({ row }) {
        return {
          claims: {
            [copycat.word(row.claims)]: copycat.words(row.claims),
          },
        };
      },
    },
    vault: {
      secrets({ row }) {
        return {
          secret: copycat.streetAddress(row.secret),
        };
      },
    },
  },
});
